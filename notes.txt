react-native-paper
Updated TextInput paddingHorizontal: 32 to 0, 


#Config Google Map
Add USE_GOOGLE_MAP system variable


#React Native Camera Header Search Path
Add: $(SRCROOT)/../node_modules/react-native/React


cd node_modules/react-native-vector-icons/bin
node generate-icon.js ~/Desktop/Linearicons/style.css --componentName=Linearicons-Free --fontFamily=Linearicons-Free > ~/Desktop/Linearicons.js
node generate-icon.js ~/Desktop/MShopFontIcon/Icon-font/style.css --componentName=mshop --fontFamily=mshop > ~/Desktop/mshop.js

#Play services version
global googlePlayServicesVersion = "16.1.0"
react-native-camera: implementation "com.google.android.gms:play-services-vision:17.0.2"
react-native-device-info: get from global

#Find dsym
mdfind "com_apple_xcode_dsym_uuids == 0E29B272-8339-3644-9B70-BCEC042BB063"
mdfind "com_apple_xcode_dsym_uuids == 04B03EB5-3C77-3717-A9DF-37D5AD34C656"

#SSL  
Cheat CA android: keyStore.setCertificateEntry("ca", ca);
Andorid exception: 
    Error javax.net.ssl.SSLPeerUnverifiedException: Hostname 192.168.43.106 not verified:
    Error java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.



    @Override
    public void registerComponents(
            @NonNull Context context,
            @NonNull Glide glide,
            @NonNull Registry registry
    ) {
//        OkHttpClient client = OkHttpClientProvider
//                .getOkHttpClient()
//                .newBuilder()
//                .addInterceptor(createInterceptor(progressListener))
//                .build();
        OkHttpClient client = OkHttpClientProvider.getOkHttpClient();
        OkHttpClient unsafeClient = getUnsafeOkHttpClient(client).addInterceptor(createInterceptor(progressListener)).build();
        OkHttpUrlLoader.Factory factory = new OkHttpUrlLoader.Factory(unsafeClient);
        registry.replace(GlideUrl.class, InputStream.class, factory);
    }

    public static OkHttpClient.Builder getUnsafeOkHttpClient(OkHttpClient client) {
        try {
            // Create a trust manager that does not validate certificate chains
            final TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
            };

            // Install the all-trusting trust manager
            final SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            // Create an ssl socket factory with our all-trusting manager
            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

            OkHttpClient.Builder builder = client.newBuilder();
            builder.sslSocketFactory(sslSocketFactory);
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });

            return builder;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    public void registerComponents(
            @NonNull Context context,
            @NonNull Glide glide,
            @NonNull Registry registry
    ) {
//        OkHttpClient client = OkHttpClientProvider
//                .getOkHttpClient()
//                .newBuilder()
//                .addInterceptor(createInterceptor(progressListener))
//                .build();
        OkHttpClient client = OkHttpClientProvider.getOkHttpClient();
        OkHttpClient unsafeClient = getUnsafeOkHttpClient(client).addInterceptor(createInterceptor(progressListener)).build();
        OkHttpUrlLoader.Factory factory = new OkHttpUrlLoader.Factory(unsafeClient);
        registry.replace(GlideUrl.class, InputStream.class, factory);
    }

    public static OkHttpClient.Builder getUnsafeOkHttpClient(OkHttpClient client) {
        try {
            // Create a trust manager that does not validate certificate chains
            final TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
            };

            // Install the all-trusting trust manager
            final SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            // Create an ssl socket factory with our all-trusting manager
            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

            OkHttpClient.Builder builder = client.newBuilder();
            builder.sslSocketFactory(sslSocketFactory);
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });

            return builder;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    

##
openssl x509 -in 2_certificate\ -\ mshop.io..crt  -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64

pQArjMM74dmwlj7Om47H7tkACnqB4K5dqSB9w/i7LRE=


2019-06-18 16:01:33.176553+0700 RnTemplate[1384:318159] 5.20.0 - [Firebase/Messaging][I-FCM001000] FIRMessaging Remote Notifications proxy enabled, will swizzle remote notification receiver handlers. If you'd prefer to manually integrate Firebase Messaging, add "FirebaseAppDelegateProxyEnabled" to your Info.plist, and set it to NO. Follow the instructions at:
https://firebase.google.com/docs/cloud-messaging/ios/client#method_swizzling_in_firebase_messaging
to ensure proper integration.

##Git tag
git tag -a v1.0.3 -m "my version 1.4"
git push origin v1.0.3
git tag -d v1.0.3
git push origin --delete v1.0.3
